""" Fonctions pour l'exploitation des frequences obtenues """
import math
from matplotlib.pyplot import *
import csv
import FFT
import listeOperation as lo


""" Fonction calculant la moyenne frequentielle ponderee par les amplitudes 
des frequences.
param : spectre -> amplitudes des frequences 
        freq    -> frequences du spectre, rangees dans le meme ordre que les 
        amplitudes
        n -> nombre de donnees dans spectre (= nb data dans freq)
"""

def pondMoy(freq,spectre,n):
    moyf = 0
    nf = 0

    for i in range(n):
        moyf = moyf + spectre[i]*freq[i]
        nf = nf + spectre[i]
    moyf = moyf/nf
    return moyf





""" Fonction qui renvoie l'écart-type autour de la moyenne ponderee.
param : freq -> frequences du spectre
        pondMoy -> la moyenne ponderee
        n -> nombre de donnees dans spectre (= nb data dans freq)
"""

def pondVar(freq,pondMoy,n):
    sum = 0
    for i in range(n):
        sum = sum + (pondMoy - freq[i])**2
    return (((math.sqrt(sum/n))*100)//1)/100





""" Fonction arrondissant un floatant à l'entier supérieur """

def arrondirSup(x):
    reste = x%(x//1)
    if (reste == 0):
        return x
    else:
        return (x//1)+1





""" Fonction calculant diverses données concernant les quartiles.
param : n -> nombre de frequences (=nombre d'amplitudes)
return : q1 -> premier quartile
         q2 -> deuxième quartile
         q3 -> troisième quartile
         inter -> ecart interquartile
"""

def quartiles(n):
    q1 = int(arrondirSup(n/4))
    q2 = int(arrondirSup(n/2))
    q3 = int(arrondirSup(3*n/4))
    inter = q3 - q1
    return q1, q2, q3, inter






#print(arrDeleteDouble([2.354,2.648,78.2452,2.47,78.364,78.0],6))


"""Fonction qui effectue le prétraitement d'un donnee z : normalisation et reduction
param : z -> variable a traiter"""

def pretraitement(z):
    n = len(z)
    moy = 0
    for i in range(len(z)):
        moy = moy + z[i]
    moy = moy/n
    sigma = 0
    for i in range(len(z)):
        sigma = sigma + (z[i] - moy)**2
    sigma = math.sqrt(sigma/(n-1))
    res = lo.sous(z,[moy for i in range(n)])
    res = lo.div(res,[sigma for i in range(n)])
    return res







""" Fonction calculant la répartition des fréquences dans le spectre. 
param : spectre -> amplitudes dans le spectre
        n -> nombre de frequences 
        nbParts -> nombre de sections de densites que l'on veut 
retour : f1, f2, ...,f(nbParts-1) de sorte que [qi:q(i+1)] contient 10% 
des frequences du spectre"""

def densite(spectre,n,nbParts):
    #Calcul de la somme totale des frequences
    sumAmp = 0
    for i in range(n):
        sumAmp = sumAmp + spectre[i]

    #Calcul des pourcentages correspondants
    pourcentages = [sumAmp*(i/nbParts) for i in range(1,nbParts)]


    #Calcul des rangs correspondants
    rangs = []
    i = 0
    pourc = 0
    suiv = 0
    while ((i < n) & (suiv < (nbParts-1))):
        if (pourc > pourcentages[suiv]):
            i = i - 1
            rangs.append(i)
            suiv += 1
        else:
            pourc = pourc + spectre[i]
        i = i + 1
    return rangs





""" Fonction traçant le spectre, avec les différentes données statistiques : 
quartiles, moyenne ponderee, variance par rapport à cette moyenne.
param : freq -> frequences dans le spectre 
        spectre -> amplitudes des frequences 
        couleur -> couleur utilisée pour tracer le spectre  
 """
def tracerSpectre(freq,spectre,couleur,nbParts):

    spectre = spectre/max(spectre)
    n = len(spectre)

    #Calcul de donnees statistiques
    moyf = pondMoy(freq,spectre,n)
    varf = pondVar(freq,moyf,n)
    rangs = densite(spectre,n)
    figure(figsize=(9,4))

    #Tracer du spectre
    vlines(freq,[0],spectre,couleur)
    #Tracer de la moyenne
    vlines([moyf],[0],[1],'lime')
    #Tracer les repartitions des densites
    vlines(rangs,[0],[1 for i in range(nbParts)],'m')
    xlabel('f (Hz)')
    ylabel('A' + "   sigma = " + str(varf))
    #axis([0,0.5*rate,0,1])
    axis([freq[0],freq[n-1],0,1])
    show()
    return rangs





def affichageSpectres(freqMin,freqMax,nbParts):
    with open("/media/ray974/common-voice/cv-valid-dev.csv", 'rt') as f:
        reader = csv.reader(f)
        nbRow = 0
        compteurH = 0
        compteurF = 0
        rangsF = [0 for i in range(nbParts-1)]
        rangsH = [0 for i in range(nbParts-1)]
        for col in reader:
            if (nbRow >= 50):
                break
            ind = ""
            for i in range(6-len(str(nbRow))):
                if (ind == ""):
                    ind = "0"
                else:
                    ind = ind + "0"
            if (col[5]=="male"):
                freq,spectre = FFT.fftFreq("/media/ray974/common-voice/cv-valid-dev/wav/sample-" + ind + str(nbRow) + ".wav", freqMin, freqMax)
                r = tracerSpectre(freq,spectre,'r',freqMax)
                rangsH = lo.add(r,rangsH)
                compteurH += 1
            elif (col[5]=="female"):
                freq,spectre = FFT.fftFreq("/media/ray974/common-voice/cv-valid-dev/wav/sample-" + ind + str(nbRow) + ".wav",freqMin,freqMax)
                r = tracerSpectre(freq,spectre,'b',freqMax)
                rangsF = lo.add(r,rangsF)
                compteurF += 1
            else:
                unknown = 1
            nbRow += 1

    #Moyenne sur les densités des amplitudes
    rangsF = lo.div(rangsF,[compteurF for i in range(len(rangsF))])
    for i in range(len(rangsF)):
        rangsF[i] = ((rangsF[i]*10)//1)/10
    rangsH = lo.div(rangsH,[compteurH for i in range(len(rangsH))])
    for i in range(len(rangsH)):
        rangsH[i] = ((rangsH[i]*10)//1)/10
    print("Moyennes hommes :" + str(rangsH))
    print("Moyennes femmes :" + str(rangsF))

